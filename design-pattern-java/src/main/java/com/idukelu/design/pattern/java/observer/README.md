## 观察者模式
- 适用场景：数据连环更新，即一个数据的更新牵连到其他多个数据的更新，类似 MQ 中的广播模式
- 替换方案：生产者消费者模式，如 MQ

## 代码缺陷及改进
### cust 包，自定义观察者模式代码中的缺陷：
问题一：主题、观察者定义不应笼统的定义为一个接口
解决一：使用笼统主题、观察者接口，采用 Java 的解决方法，即判断主题实现类是否为对应的主题，但这样会存在，主题更新时，所有观察者都会被调用 update() 方法
解决二：使用笼统主题、观察者接口，主题更新时，调用不同签名的观察者 update() 方法
解决三：按业务区分，定义不用业务的主题、观察者接口，从而避免不同业务的主题更新，调用其他业务观察者的 update() 方法

### java 包，使用 Java 提供的观察者模式：
问题一：即原罪，Java 提供的 Observable 类，但不推荐，这个类已经非常老了。底层采用 Vector 作为容器，且面向类编程，导致这种方法的扩展性较差
问题二：无法按业务定义不用业务的主题、观察者，导致主题更新时，所有观察者都会被调用 update() 方法，这时只能通过判断主题类型来实现是否执行更新操作
解决：业务简单时可以使用 Java 这种方式，但最好不要用Java 提供的观察者模式